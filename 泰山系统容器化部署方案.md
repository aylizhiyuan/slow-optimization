# <center>泰山系统容器部署规范草案</center>

## 1、日志输出规范 （ 20 人 / 天）

### 1.1、问题代码查找方案

目前泰山系统中所有的日志都来自于pm2的日志,研发通过console.log将需要打印的信息输出到stdout中,由pm2来负责管理out日志和error日志.日志的存放路径默认是~/.pm2/logs/app-error.log ~/.pm2/logs/app-out.log中,日志以字符串格式无规律存储

问题日志代码的查找方式是`全局搜索console.log`打印日志代码，将所有的代码全部注释,并在eslint中开启禁止使用console.log规则,禁止产生任何console.log规则


### 1.2、合规代码实现方案

研发打印日志可以使用log4js日志模块,该模块有trace/debug/info/warn/error等日志级别,可以根据实际情况使用log4js的对应方法调用

配置代码

```
const log4js = require("log4js");
const express = require("express");
const fs = require('fs');
log4js.addLayout('json', config => function (logEvent) {
  return JSON.stringify(logEvent) + config.separator;
});
log4js.configure({
  //输出信息
  appenders: { 
    out:{ 
      type:"file",
      filename:"app.log",
      layout: { type: 'json', separator: ',' }
    },
  },
  // 输出的配置
  categories: { 
    // 高于info级别的日志都会被记录下来,并且会使用调用堆栈在事件中生成行号和文件名
    default:{ appenders: ["out"], level: "debug",enableCallStack:true},
  },
  
  // 如果使用的pm2进程的话，需要设置该设置,并安装pm2的模块pm2 install pm2-intercom
  // pm2:true
});
```

调用代码

```
app.get('/',function(req,res){
    // 关于程序报错和调试信息使用logger来记录
    // 1.推送给http
    // 2.记录在.log日志中
    // 3.直接使用pm2中的app-out.log，但是无法固定格式
    // 进程中的运行时报错pm2 记录,默认的地址是.pm2/logs/app-error.log
    var obj = {name:"sdfsdf",age:323,text:{firstname:"12",lastname:"sdfsdf"}}
    logger.info("打印内容..",obj);
    try{
     var people =  people.findById('test');
    }catch(e){
      logger.error('错误的对象'+ e); // 妈的，原来是这么玩儿的..
      res.end("hello world");
    }
    // res.end("hello world");
})
```

### 1.3、问题代码替换方案

该日志无需替换方案,旧的代码全部注释,所有的新log会以文件或者其他传输方式传输到指定的地方,关于PM2进程中的error日志仍然需要单独存储----引起Pm2进程挂掉的错误不会被直接记录，仍然需要通过pm2的报错日志查看具体引起进程挂掉的原因....log4js主要的目的是让程序员主动记录错误和打印的内容



## 2、临时文件路径修正方案（ 100 人 / 天）


### 2.1、问题代码查找方案

搜索exec(ccmd 关键词找到的代码就是生成临时文件的所有代码

### 2.2、合规代码实现方案

***读取excel实例***

```
// 将excel里面的内容读出来
const Excel = require('exceljs');
const workbook = new Excel.Workbook();
async function main(){
    await workbook.xlsx.readFile('./1.xlsx');
    workbook.eachSheet(function(worksheet, sheetId) {
        var worksheet = worksheet;
        worksheet.eachRow(function(row, rowNumber) {
            console.log('Row ' + rowNumber + ' = ' + JSON.stringify(row.values));
        });
    });
    
}
main();
```

***写入excel实例***

```
// 将内容写入到excel文件中去
const Excel = require('exceljs');
// 写入文件
const workbook = new Excel.Workbook();
async function main(){
    await workbook.xlsx.writeFile('./test.xlsx');
}
main()
```


### 2.3、问题代码替换方案

下载xlsx的情况:

- 从oss中下载

```
// gfs的可读流读出xlsx的文件
var readstream = gfs.createReadStream({
    _id: params.file
});
// 临时文件存储
var url = fs.realpathSync(__dirname + '/../tools') + '/upload_paaf_base_' + wk_name + '.xls';
// 将gfs中的流流入到临时文件中，临时文件获取到了oss中的xlsx的内容
readstream.pipe(fs.createWriteStream(url));
// 将json的信息写入到临时xlsx中去,完成了数据的拼装后结束下载
var ccmd = [params.cmd_excel.join(' '), url, temp_file_excel].join(' ');
exec(ccmd, function(err, stdout, stderr) {}
```

> 替换思路:直接读取xls文件,填入数据后,直接下载,不需要json处理


上传xlsx的情况:

- 用户的信息填写完毕后整理好,直接将内容写入到xlsx中后,再进行上传即可.

```
// 创建json文件
url = fs.realpathSync(__dirname + '/../tools') + '/pa_event' + wk_name + '.json';
// 将内容扔到json文件中
fs.appendFile(url, result_str, 'utf-8', function(err) {}
// 通过脚本解析json文件，并创建xlsx文件
var ccmd = [cmd.join(' '), url].join(' '); 
exec(ccmd, function(err, stdout, stderr) {
  // 解析成了xlsx文件
}
// 上传xlsx文件
var put = require('../utils/ali_oss').put;
// console.log('==上传oss==')
put(excel_url, params.excel_name + (new Date().getTime())+'.xls', function(err, url){
  // 上传oss成功
}
```
> 替换思路:直接创建xlsx文件，并写入数据后，上传oss


## 3、时间驱动任务代码编写规范（ 60 人 / 天）


### 3.1、问题代码查找方案

系统中的定时任务都在clis目录中，包含所有的js文件，定时任务可以通过module.exports查看对应每个文件的个数

### 3.2、合规代码实现方案

该代码以进程的形式运行，进程运行期间如果满足了触发条件后自动会进行任务的调度，属于进程内调度，缺点明显：进程保持运行状态，无法关闭，始终占用资源，优势：程序员可主动控制进程中的异常和输出信息，可及时的发现和监控

任务1
```
const CronJob = require('cron').CronJob;
console.log("开始执行定时任务1....");
// 向子进程发送消息
const job = new CronJob('*/5 * * * * *', function() {
    try{
        const d = new Date();
        console.log(`pid-${process.pid} 每五秒打印一下当前时间任务:`, d);
        // 当前子进程出问题了....
        // throw new ReferenceError("代码级别的错误....");
    }catch(error){
        console.log(error) //后期考虑更好的方式记录错误日志
    }
});
job.start();
// 子进程收到消息的时候的处理...
process.on("message",function(msg){
    console.log(`子进程收到消息: ${msg}`)
})

// 你可以理解为这个是我们无法手动捕获的系统错误,在这里抛出,不会让当前进程杀死....
process.on('uncaughtException', function (err) {
    console.log(`pid-${process.pid} Caught exception: ${err.stack}`);
    // 默认可能process.exit(1)了直接就...
});

// 重点在于子进程要发送数据给主进程
```
任务2
```
const CronJob = require('cron').CronJob;
console.log("开始执行定时任务2....");
// 向子进程发送消息
const job = new CronJob('*/10 * * * * *', function() {
    try {
        const d = new Date();
        console.log(`pid-${process.pid} 每10秒打印一下当前时间任务:`, d);
        // 当前子进程出问题了....
        throw new ReferenceError("代码级别的错误....");
    } catch (error) {
        console.log(error) //后期考虑更好的方式记录错误日志
    }
});
job.start();
// 子进程收到消息的时候的处理...
process.on("message", function(msg){
    console.log(`子进程收到消息: ${msg}`)
})

// 你可以理解为这个是我们无法手动捕获的系统错误,在这里抛出,不会让当前进程杀死....
process.on('uncaughtException', function (err) {
    console.log(`pid-${process.pid} Caught exception: ${err.stack}`);
    // 默认可能process.exit(1)了直接就...
});
```


 定时任务的启动代码
```
// 对定时任务要实现监控
// 1. 首先创建对饮的定时任务

const child_process = require('child_process');
const express = require('express');
var path = require('path');
// 加载配置文件
const server_config = require('./server_config.json');
const taskList = server_config.cronList;



const app = express();
var task = [];

app.get('/api',function(req,res){
    console.log("此路径为了对定时任务进行增删改查操作....")
})
app.get("/web",function(req,res){
    console.log("此路径是为了提供一个web界面用来管理所有的定时任务")
})
// 定时任务服务器启动的时候将所有的定时任务启动
// 考虑两个问题,当子进程的任务出现失败的时候如何重启?
// 当子进程的任务报错的时候如何及时发现？
for(let i=0;i<taskList.length;i++){
    let taskPath = path.join(__dirname + taskList[i]);
    task[i] = child_process.fork(taskPath);
    console.log(task[i]);
    task[i].on('message',function(msg){
        // 处理子进程发来消息
        console.log(msg);
    })
    task[i].on('close',function(){
        // 子进程关闭的情况
        console.log(`pid-${task[i].pid} 关闭...`)
    })
    task[i].on('error',function(){
        // 子进程失败
        console.log(`pid-${task[i].pid} 失败...`)
    })
    task[i].on('exit',function(){
        // 子进程退出(几乎不会主动退出)
        console.log(`pid-${task[i].pid} 退出...`)
    })
}
app.listen(8888,function(){
    console.log("定时任务监控系统开启.....");
})


// 向子进程发送消息,通常就是关闭某个子进程的时候
// task.send("我是父进程....");

// 保证主进程不会退出....类似于全局范围内的try{}catch(){}
process.on('uncaughtException', function (err) {
    err.name = "UncaughtExceptionError";
    console.log('Caught exception: ' + err.stack);
});

// 父进程是不不会主动退出的，不用考虑process.on(exit)
// 当你向父进程发送杀死的信号的时候，需要将所有的子进程全部关闭
process.on("SIGINT",function(){
    try{
        for(let j=0;j<task.length;j++){
            console.log(task[j].pid);
            process.kill(task[j].pid,"SIGKILL");
        }
    }catch(e){
        process.exit(1);
    }
    process.exit(1);
})
// 当向父进程发送kill命令信号的时候,需要将所有的子进程全部关闭
process.on("SIGTERM",function(){
    try{
        for(let k=0;k<task.length;k++){
            // 向所有的子进程发送信号
            process.kill(task[k].pid,"SIGKILL");
        }
    }catch(e){
        process.exit(1);
    }
    process.exit(1);
})
```

### 3.3、问题代码替换方案

- 将所有的定时任务整理出来后，每一个定时任务都单独放置在一个文件中
- 将所有的定时文件改写为cron模块的运行方式
- 创建http服务器，从而采用fork的方式衍生定时任务的子进程，子进程退出后,由父进程收集并整理，并报告.
- 因为定时任务是需要长期保持运行状态的，一旦某个定时任务出现问题，主进程可监控发现



## 4、非服务进程代码编写规范（ 30 人 / 天）

### 4.1、问题代码查找方案

非服务进程代码是指需要运行一遍就直接退出的代码,这类型的代码更多针对的是跑数据库操作,目前泰山系统项目中存在少量这种js文件，暂时的解决方案是保持原有的文件，如再次遇到需要跑的进程代码，需要严格按照规定，放到临时的文件中保存.

### 4.2、合规代码实现方案

```
async function runServer(){
    try{
        // 运行项目代码...
    }catch(e){
        // 遇到错误的时候...
    }.finally{
        // 始终要将非服务进程的代码进程结束
        process.exit(0)
    }
}
```

### 4.3、问题代码替换方案

无问题代码的替换方案，以后将非服务进程的代码书写规则整理到nodeJS代码实践规范中去...



## 5、服务进程代码编写规范（ 60 人 / 天）

### 5.1、问题代码查找方案

泰山系统队列使用rabbitMQ,rabbitMQ以进程形式运行，一般不会主动关闭,所有的队列进程都在/queue文件夹中。设计到的队列数量大约200个左右

### 5.2、合规代码实现方案

```
var forever = require('forever-monitor');
  var path = require('path');
  var child = new (forever.Monitor)(path.join(__dirname,'child.js'), {
    "uid":'you-UID', // 该进程的uid号码
    "pidFile":"path/to/a.pid", // 放置该进程信息的pid路径
    "max": 10, // 重启的次数
    "silent": true, // 是否关闭子进程的输出到父进程,true为默认
    'killTree': true,           // 关闭当前进程的时候是否杀死子进程
    'minUptime':2000, // 该进程必须启动的最短时间，否则则永远不启动
    'spinSleepTime':10000, // 进程重启的时间间隔
  });
  // 当前子进程退出的时候触发
  child.on('exit', function (forever) {
    console.log('任务1退出了.... ');
  });
  // 当前子进程发生错误的时候触发
  child.on('error',function(err){
    console.log("任务1发生错误了.... ")
  })
  // 当前子进程开始的时候
  child.on('start',function(process,data){
    console.log('任务1开始运行了... ')
  })
  // 当前子进程停止的时候
  child.on("stop",function(process){
    console.log('任务1已经停止运行了.... ')
  })
  // 当前子进程重启的时候
  child.on('restart',function(forever){
    console.log("任务1正在尝试重启中... ")
  })
  // 当前子进程有输出的时候
  child.on('stdout',function(data){
    console.log("任务1正在工作... ")
  })
  // 当前子进程有输出错误的时候
  child.on('stderr',function(data){
    // console.log('任务1正在输出报错信息... ')
  })
  child.start();
  var child2 = new (forever.Monitor)(path.join(__dirname,'child2.js'), {
    "uid":'you-UID', // 该进程的uid号码
    "pidFile":"path/to/a.pid", // 放置该进程信息的pid路径
    "max": 10, // 重启的次数
    "silent": true, // 是否关闭子进程的输出到父进程,true为默认
    'killTree': true,           // 关闭当前进程的时候是否杀死子进程
    'minUptime':2000, // 该进程必须启动的最短时间，否则则永远不启动
    'spinSleepTime':1000, // 进程重启的时间间隔
  });
  // 当前子进程退出的时候触发
  child2.on('exit', function (forever) {
    console.log('任务2退出了...');
  });
  // 当前子进程发生错误的时候触发
  child2.on('error',function(err){
    console.log("任务2发生错误了... ")
  })
  // 当前子进程开始的时候
  child2.on('start',function(process,data){
    console.log('任务2开始启动了...')
  })
  // 当前子进程停止的时候
  child2.on("stop",function(process){
    console.log('任务2停止运行了...')
  })
  // 当前子进程重启的时候
  child2.on('restart',function(forever){
    console.log("任务2正在尝试重启.... ")
  })
  // 当前子进程有输出的时候
  child2.on('stdout',function(data){
    console.log("任务2正在工作中... ")
  })
  // 当前子进程有输出错误的时候
  child2.on('stderr',function(data){
    // console.log('任务2正在输出错误信息....')
  })
  child2.start();

```

### 5.3、问题代码替换方案

- 队列的逻辑代码不变,文件不变，在处理异常过程中,除了常规的ACK之外,异常情况下可选择性的将进程杀死,进程可由程序控制重启

- 之前启动队列是使用shell脚本启动queue.sh 来启动所有的队列,现在直接由代码控制，只要将主进程开启---改变队列的启动方式即可，主进程会fork相应的子进程队列，并监控子进程队列，失败后有重启机制，并可将错误信息报告给研发，主动得知报错信息.



## 6、URL路径编写规范（ 30 人 /  天）

### 6.1、问题代码查找方案

在项目中搜索关键词`www.zhisiyun.com`以及`cache.zhisiyun.com`找到的所有相关域名的绑定代码



### 6.2、合规代码实现方案

```
// 前端原始方案(搜索结果1114个文件)
script(type="text/javascript", src="https://www-cache.zhisiyun.com/js/plugins/JQuery-zTree-v3.5.14/js/jquery.ztree.exhide-3.5.min.js")

// 前端改造方案 ,也可以通过location.host获取域名信息
script(type="text/javascript",src="#{path_js_page}/../js/pdf/pdf.js")


// 后端原始方案(搜索结果388个文件)
var url_datas = {
        "AssessmentInstance_plan":'https://www.zhisiyun.com/wxapp/004/getGoDo/3/' + op_id + '/1/' + client.qywx_corpid,//绩效计划阶段
    }

// 后端改造方案
// 读取配置文件中的信息
nconf.file({
    'file': __dirname + '/cli_config.json'
});
// 获取host信息
var host = nconf.get('host');

```

#### 6.3、问题代码替换方案

使用全局匹配的方式逐一分批次的将同一文件夹下面的js文件替换


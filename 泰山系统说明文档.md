# 项目代码目录结构分析总结

## 1. webstorm调试技巧 + vscode调试技巧

配置好Nodejs之后，我们就可以直接使用webstorm进行代码的调试了，直接右键--->debug app.js即可，非常的简单

这里，打好端点之后，可以在以下界面中执行代码的调试工作

- step over 不进入子函数的单步调试模式
- step into 进入子函数的单步调试模式
- force step into 可能会进入系统源代码的单步调试模式
- step out 退出单步调试模式
- run to cursor 跳到鼠标放置的位置（这一步感觉比断点好用啊）

> vscode非常的简单，配置好lunch.json文件后直接在需要debug的地方打上断点即可。如需看配合请求的话，直接刷新浏览器即可



## 项目用到的一些第三方的模块，重点的列出

- connect-flash 这个玩意儿之前就用过，用来在页面直接输出的
- connect-mongo 这个是session存储mongo的一个库
- colors 输出文字的颜色设置
- passport 一个封装的验证用户名、密码、三方登录的插件
- passport-local 这个是专门用于本地用户名、密码的应用
- bcrypt 加密模块
- moment 时间格式化模块
- sprintf 这个模块是实现了printf打印的格式化
- async 这个是一个异步的库
- gridfs-stream 这个应该是mongodb的模块的流操作
- expiry 设置静态文件的失效时间的模块
- nconf 这个模块应该是根据当前的环境可以设置一些配置文件、环境变量的模块
- connect-redis 连接redis数据库
- i18next多语言的支持

## 核心启动文件app.js的启动流程分析

1. 加载核心配置文件server_config.json,这个文件是通过nconf来加载的,获取的时候直接通过nconf.get来获取即可,这个确实只是将配置参数想办法存储一下


- development 开发环境
    - mongodb_url MongoDB数据库的连接地址
    - redis Redis好像是有两个地址,一个是session,一个是cache
    - elasticsearch 这个应该是企业内部使用的一个分析可视化数据的平台地址
    - page_js_page 这个是我们页面使用的js文件夹的位置

- production 生产环境

    -同上类似

2. passport passort-local来完成本地的登录

        var express = require('express');
        var cookieParser = require('cookie-parser');
        var session = require('express-session');
        var flash = require('express-flash');
        var passport = require('passport');
        ...
        //配置模板引擎
        //这之前可能会加载一些bodyparser/logger/favicon
        app.use(cookieParser());
        app.use(session({...}));
        app.use(passport.initialize());
        app.use(passport.session());
        app.use(flash())
        //后面跟我们自己的路由或者静态文件访问即可

- 做验证之前，首先对策略进行配置

        var passport = require('passport')
        , LocalStrategy = require('passport-local').Strategy;
        passport.use(new LocalStrategy(
        function(username, password, done) {
            //查询当前用户名是否存在
            User.findOne({ username: username }, function(err, user) {
            if (err) { return done(err); }
            if (!user) {
                return done(null, false, { message: '用户名不存在.' });
            }
            //这里可以写成自己的验证方法
            if (!user.validPassword(password)) {
                return done(null, false, { message: '密码不匹配.' });
            }
            return done(null, user);
            });
        }
        ));

- session序列化与反序列化

        passport.serializeUser(function(user, done) {
        done(null, user.id);
        });
        passport.deserializeUser(function(id, done) {
        User.findById(id, function(err, user) {
            done(err, user);
        });
        });

第一段代码是将环境中的user.id序列化到session中，同时把它作为凭证存储到用户的cookie中,其实就是done中传递的用户信息

第二段代码就是从session反序列化，参数为用户提交的session,如果再服务器中查到了则证明用户已经登录了

- 直接来做authenticate验证

        app.post('/login',
        passport.authenticate('local',
            { successRedirect: '/',
            failureRedirect: '/login',
            failureFlash: true }),
        function(req, res) {
            // 验证成功则调用此回调函数
            res.redirect('/users/' + req.user.username);
        });

- 如果是第三方登录的话，需要使用oauth验证

    1. 为你的app去第三方服务商处申请标识和令牌appkey和secret
    2. 为你的app里添加按钮或链接，将用户引导至服务商的授权页，用户在这里选择授权给你的app
    3. 授权成功后跳转回你的app,同时还传递access_token和用户资料
    4. 之后可以做自己想做的事儿了

实例的代码

        var passport = require('passport')
        , OAuth2Strategy = require('passport-oauth').OAuth2Strategy;
        passport.use('provider', new OAuth2Strategy({
            authorizationURL: 'https://www.provider.com/oauth2/authorize',
            tokenURL: 'https://www.provider.com/oauth2/token',
            clientID: '123-456-789',
            clientSecret: 'shhh-its-a-secret'
            callbackURL: 'https://www.example.com/auth/provider/callback'
        },
        function(accessToken, refreshToken, profile, done) {
            //这里面应该是我们的逻辑，到底应该是直接登录还是注册新用户
            //还是做别的其他的操作
            User.findOrCreate(..., function(err, user) {
            done(err, user);
            });
        }
        ));

下面是路由的写法

        app.get('/auth/provider',
        passport.authenticate('provider', { scope: 'email' })
        );
        app.get('/auth/provider/callback', 
        passport.authenticate('provider', { successRedirect: '/',
                                            failureRedirect: '/login' }));

- 第三方登录的验证功能

虽然我们是可以完成第三方的验证了，但是，第三方的处理逻辑要明白

当用户点击"使用xxx登录"连接

情况1: 若用户已经登录了

检查该用户是否已经绑定了，如果已经绑定了不允许重复绑定，否则开始验证流程，为用户的用户名和密码绑定微信

情况2: 若用户未登录

如果是老用户，则登录，如果是新用户的话，创建一个新的账号


## 3.nodeJS中的错误处理

        // 捕获可以让系统崩溃的错误，避免进程反复重启
        process.on('uncaughtException', function (err) {
            err.name = "UncaughtExceptionError";
            console.log('Caught exception: ' + err);
        });

## 4. 开始处理路由

    require('./routes/init')(app);
    require('./routes/index')(app, checkAuth);
    require('./routes/auth')(app, checkAuth); 
    require('./routes/user')(app, checkAuth);
    require('./routes/admin')(app, checkAuth);
    require('./routes/api')(app, checkAuth);
    require('./routes/render')(app, checkAuth);

需要权限的地方都是在/routes/auth里面。路由实在太多了，挑着看吧，如果真的是一个个的看，那恐怕要挂掉的

## 5. cookie session

        // 使用 cookieParser 中间件;
        app.use(cookieParser());
        // 如果请求中的 cookie 存在 isFirst
        // 否则，设置 cookie 字段 isFirst, 并设置过期时间为10秒
        app.get('/', function(req, res) {
            if (req.cookies.isFirst) {
                res.send("再次欢迎访问");
                console.log(req.cookies)
            } else {
                res.cookie('isFirst', 1, { maxAge: 60 * 1000});
                res.send("欢迎第一次访问");
            }
        });

这个cookie-parser比较简单，无非就是设置cookie和获取cookie

如果需要对cookie进行加密的话，也可以这么来

        // 使用 cookieParser 中间件;
        app.use(cookieParser('my_cookie_secret'));

        // cookie
        app.get('/', function(req, res) {
            if (req.signedCookies.isFirst) {
                res.send("欢迎再一次访问");
                console.log(req.signedCookies)
            } else {
                res.cookie('isFirst', 1, { maxAge: 60 * 1000, signed: true});
                res.send("欢迎第一次访问");
            }
        });

从上面的代码我们可以看到cookie-parser的第一个参数可以指定服务器端的加密秘钥，我们可以使用options的signed配置项可实现加密

express-session是用来创建session的

        var session = require('express-session');

        var se = session(options);

- name: 设置cookie中，保存session的字段名称，默认为connect.sid
- store: session的存储方式，默认为存放在内存中，我们可以自定义redis等
- genid: 生成一个新的session_id时，默认为使用uid2这个npm包
- rolling: 每个请求都重新设置一个cookie，默认为false
- resave: 即使session没有被修改，也保存session值，默认为true
- saveUninitialized：强制未初始化的session保存到数据库
- secret: 通过设置的secret字符串，来计算hash值并放在cookie中，使产生的signedCookie防篡改
- cookie : 设置存放sessionid的cookie的相关选项

简单的说，这个插件是用来创建session的，创建的sessionID会保存在客户端的cookie中，名称默认是connect.sid,secret加密后就是对应的值

我们可以通过设置req.session.cookie.maxAage来设置session的有效期，一旦超过这个时间的话，我们就不可以访问到session了

        app.use(function (req, res, next) {
                if (req.method == 'POST' && req.url == '/login') {
                    if (req.body.rememberme) {
                        req.session.cookie.maxAge = 2592000000; // 30*24*60*60*1000 Rememeber 'me' for 30 days
                    } else {
                        req.session.cookie.maxAge = 15 * 60 * 60 * 1000;
                        // req.session.cookie._expires = true;
                        // console.log(req.session.cookie);
                    }
                } else {
                    // req.session.cookie.maxAge = 15 * 60 * 1000; //15分钟内不动系统，就退出。
                }
                next();
            });

一般判断用户是否登录我们就可以用req.session.user来判断了

默认情况下session是放在内存中的，但是，我们可以使用mongodb或者是redis来保存，这样我们就可以减少内存的消耗，同样，我们可以使用过期时间来约束session的使用.

## 6. redis


让我们来感受一下整个流程是如何的

任何一个陌生的人打开这个网站，都会因为app.use(session())为他单独生成一个session,这时候因为我们的store设置，所以，每个人的session是保存在redis中的，类似于下面的


    {"cookie":{"originalMaxAge":null,"expires":null,"httpOnly":true,"path":"/"},"passport":{},"flash":{}}

注意，它同时也会为这个客户在它自己的浏览器中生成一个cookie - connect.sid，至于为什么，我还没有考虑清楚

这时候，你可以想象，每个用户如果都把session放在内存中，那么session的量就会特别的大，所以我们才需要将session放到redis中存放起来，取的时候从redis中取出要比去内存中取速度更快一些

当一个用户登录的时候打开/login的时候，输入用户名、密码，验证成功后，它对应的session就会变成这个样子

    {"cookie":{"originalMaxAge":54000000,"expires":"2019-10-14T00:04:51.843Z","httpOnly":true,"path":"/"},"passport":{"user":"585a17b62098688d02eeb036"},"flash":{}}

这里面保存着它的session的有效期和过期的时间，以及passport中用户的id信息

这时候我们就可以用req.session.user对用户是否登录进行判断了，因为这里用了passport所以可能是req.session.passport.user来进行判断了(或者生成其他的session值也可以)

> 在我们的项目中,有两个redis地址，一个是db0 cache,一个是db1 session,一个用来存放缓存数据，一个用来存放session

用户如果这时候退出了，它的session信息应该清除，如果这时候他再次登录的话，我们会为他重新生成一个新的session,它的connect.sid也是不同的

如果是一个用户重复登录是不是就会生成多个session呢？结果是不会，因为什么呢？因为这个用户的本地是保存着sessionID的，如果是相同的sessionID是不会创建多个session的.（依据就是他是否携带已经存在的cookie）

- 任何一个用户在未登录的情况下访问网站都会被生成一个新的session,这个新的session是空的
- 通过cookie来记录这个未登录用户的sessionID，防止它重复登录生成无数的session
- 用户跳转到登录页面，填写登录用户名密码，sessionID也会被发送出去
- 服务器根据用户cookie中的sessionID，找到属于自己的session
- 将用户的信息存到自己的session中去，用户变为登录状态
- 如果需要设置超时时间的话，可以在用户登录的时候发请求的时候设置req.session.cookie.maxage来改变session的超时时间，当超时的时候，session便访问不到了
- 用户登出的时候，它自己的session信息要清除,并且要将cookie也删掉，这样，它下一次想登录的时候，就立刻会再次生成新的session
- 如果在不退出情况下，该用户继续登录，也只会修改同一个session,不会创建新的session



## 8.消息队列--rebbitmq

消息队列是一种应用间的通信,消息发送后可以立即返回，由消息系统来确保消息的可靠传送，消息发布者只管把消息发送到MQ中而不用管谁来取，消息使用者只管从MQ中取得消息而不用管是谁发的，这样发布者和使用者都不知道对方的存在

我们一般在项目中是为了解决密集型的任务，避免立即执行资源密集型的任务，而不是要等待它完成。相反，我们安排任务以后完成，

安装
    npm install rabbitmq

运行，进入/usr/local/Celler/rabbitmq/3.7.7

    sbin/rabbitmq-server 

启动http的插件

    rabbitmq-plugins enable rabbitmq_management

这时候可以登录到管理的界面 locahost:15672 可以观察消息队列的情况

    http://localhost:15627 默认的用户名和密码是guest guest

我们项目的地址是http://121.41.48.37:15672 输入用户名密码即可登录

网上可以找到很多node种操作rabbitmq的工具，这里推荐使用amqplib


- 工作队列
- 发布订阅
- 路由
- 话题
- RPC

一共这么多个模式，项目代码中用的其实就是简单的发布订阅的功能，简单的说就是比如我向某某某发送了一封邮件，我可以将这个业务写在消息队列中，我发邮件的这个行为会经过邮局转到目标人手里，这个目标人可以是多个，也可以是单个

整体的流程如下:生产者将消息发送到交换机，交换机将任务推入到队列中，所有的用户从各自的队列中拿到消息

1. 创建一个交换机 

        //类型可以有多种选择，例如direct,topic,headers,fanout
        ch.assertExchange('logs','fanout',{durable: true})

2. 发布到交换机

        channel.publish('logs','',Buffer.from('hello world'))

3. 新建一个队列，临时的队列

        channel.assertQueue('',{
            exclusive:true
        })

4. 将这个临时的队列跟交换机绑定在一起

        channel.bindQueue(queue_name, 'logs', '');

5. 接收的代码同样需要执行上面的操作，只不过我们最后的时候是为了消费这个任务，也就是执行相关的操作

        channel.consume(queue,function(msg){
            //里面具体的写我们的执行代码
        })

举例说明:

比如说我要给很多人发邮件，那么我可以用publish去作为一个生产者，传递一些发送邮件的参数，然后consume会帮我们执行，在回调函数中我们就可以直接写我们的发布逻辑了，如果要给多个人发送邮件的话，我们可以多次调用publish去发送...consume会自动的执行



## 9.登录注册和权限判断

登录的时候应该是先查询client表--->user表，比对用户名密码之后

将用户的信息记录在req.session.passport的user字段中

登出的时候直接将cookie和session清除掉

各个页面打开的时候将用户的信息保存起来，判断是否存在用户的信息即可

感觉这里是个重大的bug,req.user存放用户的信息，貌似没有过期的时间，也没有有效的判断用户


## 10. 写项目的流程


先搞清楚整个jade中布局

        //base_user2
        我们的头部和导航部分,这里主要是这个,其他的没有内容
        block page-plugin
        block page-script
        block page_script

        //layout_user
        extends base_user2

        block page-plugin

        block page-script

        //index_new
        extends /new_pc/layout_user

        block page-title
            //这个应该是我们的网站的标题
        block page-content
            //这应该是我们的网站的主题内容
            //我们应该是从这里开始写页面的
        block page-script
            //这里是我们自己的js文件


        我们写页面的时候可以直接用layout_admin.jade

        //我们的头部和导航
        block page-plugin
            //页面需要用到的插件
        block page-script
            //页面自己的js文件
        block page-content
            //页面的内容
            block content
                //应该也是页面的内容 


1. 首先创建自己的分支

        在主分支中 git branch 新的分支
        在新分支中开发完成功能后,切换到qas git checkout qas
        保险起见，拉取一下qas分支的最新内容 git pull origin qas
        在qas分支中将我的分支合并 git merge 新的分支
        查看状态解决冲突 git status
        git push origin qas
        提交测试

2. 先找路由,routes文件，找到页面的路由处理函数



如需新增导航的页面的话，建议直接在routes/里面创建一个以recruitment_功能名称.js的文件,在recruitment.js中引入(需要修改导航菜单添加新的路由链接)

    require('./recruitment_功能名称')(app,checkAuth)

如果需要在已有的导航页面中添加新的页面的话，那么就需要找到该页面的路由处理函数

    app.get(__base_path + '/panel_list', checkAuth, rt_list);

进行添加和修改即可

下面就是查看路由的处理函数

    var rt_list = function(req, res) {
    var i18n = req.i18n;
    var client = req.user.client.id;
    var render_data = {
        title: i18n.t("app:admin.recruitment.panel_list.Recruitment configuration"),//'招聘配置',
        user: req.user,
    };
    res.render('admin/recruitment/panel', render_data)

};

然后我们熟悉下所使用到的数据库的表

所有的数据库的表都放在了models里面，找到我们对应的recruitment.js

    //先把schema全部拿出来
    var recruitment = require('../schemas/recruitment');
    //表生成模型都是在这个地方生成的
    module.export.某个表 = mongoose.model('表名',schema);
    //对外暴露表

1. 首先找到对应的schema 添加schema
2. 找到对应的model 生成model
3. 调用model文件直接可以调用方法来进行操作了

常见的查询

        MyModel.find({条件}).where().gt().lt().limit().sort(字段:'asc').in(['数组']).select(要查询的字段).exec(function(){})

findByIdAndUpdate 根据id查询并更新

create() 新增

update() 更改

remove() 删除

新增多个值到数组 

    "$push":{"bank_types":{"$each":bank_types}}  
    {$push:{question_tags:mult_tag_list}}

删除某个值到数组 

        {$pull:{bank_tags:del_tag_name}}

判断是否在数组中

        Menu.find({
            menu_code: {$in: ['COMPENSATION_SUBSIDY_REPORT_MENU', 'COMPENSATION_SUBSIDY_SUMMARY_MENU']}})  

批量删除或者新增的话可以使用

        async.ForEach([id数组],function(item,callback){})

关联查询  
        
        .populate({path: 'round',select: '_id rd_name rd_type'})

多个操作的时候建议使用Promise,回调比较多的情况下，将任务放入promise中去使用

聚合查询的标准
        //注意要加上ObjectId()来转化ID
        People.aggregate({
        $match:{
            client:ObjectID("5cf631a71dc8ccb72bba2a57"),
            employee_status:{
                "$in":["P","H","S"]
            },
            block:false
        }
    },{
        $lookup:{
            from: "clients",
            localField: "client",
            foreignField: "_id",
            as: "client" //可覆盖之前的字段
        }
    },{
        $project:{
            "_id":1,
            "history_position":1,
            //client:1,
            "client._id":1, //这里指定关联表中的具体字段
            "client.address":1
        }
    }).exec(function(err,result){
        return res.send(result);
    })


## 11. 常用的js操作工具类

1. 数组、对象通用的

        //遍历所有元素，按顺序用每个元素当做参数调用后面的函数进行处理
        //常用于批量的新增、删除操作    
        _.each({one:1,two:2,three:3},function(element,index,object){})

        //对数据进行处理，并返回一个新的数组或者对象
        //常用于对数据进行批量的修改
        _.map(list,function(index,value){return value * 3})

        //常用于数据的聚合操作，memo为上一次return的最后的值
        //用于累加、累计
        var sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0);
        => 6

        //找到符合条件的数据则立刻停止
        //适合于找到第一个符合条件的数据
        var even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
        => 2

        //过滤数据，找到符合条件的数据，用于批量找到所有符合条件的
        var evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
        => [2, 4, 6]

        //跟filter正好相反，返回不符合的数据
        var odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
        => [1, 3, 5]

        //判断是否都符合条件，如果都符合条件就返回true,否则返回false
        _.every([2, 4, 5], function(num) { return num % 2 == 0; });
        => false

        //只要有一个符合条件就返回true
        _.some([null, 0, 'yes', false]);
        => true

        //判断是否包含indexOf某个值
        //但是好像是没办法在比对另外一个数组
        _.contains([1, 2, 3], 3);
        => true

        //返回对象的键或者值
        //以数组的形式返回，感觉这个方法的意义挺大
        var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
        _.pluck(stooges, 'name');
        => ["moe", "larry", "curly"]

        //返回最大值、返回最小值
        var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
        _.max(stooges, function(stooge){ return stooge.age; });
        => {name: 'curly', age: 60};
        
        var numbers = [10, 5, 100, 2, 1000];
        _.min(numbers);
        => 2

        //排序，按照某个字段排序或者是按照某个规则排序
        _.sortBy([1, 2, 3, 4, 5, 6], function(num){ return Math.sin(num); });
        => [5, 4, 6, 3, 1, 2]

        var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
        _.sortBy(stooges, 'name');
        => [{name: 'curly', age: 60}, {name: 'larry', age: 50}, {name: 'moe', age: 40};

        //按照某个规则分组
        _.groupBy([1.3, 2.1, 2.4], function(num){ return Math.floor(num); });
        => {1: [1.3], 2: [2.1, 2.4]}

        _.groupBy(['one', 'two', 'three'], 'length');
        => {3: ["one", "two"], 5: ["three"]}
        

        //排序一个列表组成多个组并返回各个组中的数量
        _.countBy([1, 2, 3, 4, 5], function(num) {
        return num % 2 == 0 ? 'even': 'odd';
        });
        => {odd: 3, even: 2}

        //将对象转化为数组
        (function(){ return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
        => [2, 3, 4]

2. 数组

        //组成一个大数组
        _.flatten([1, [2], [3, [[4]]]]);
        => [1, 2, 3, 4];

        //多个数组比较，返回不存在第二个数组中的第一个数组的值
        _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
        => [1, 3, 4]

        //多个数组的并集，数组值唯一
        _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
        => [1, 2, 3, 101, 10]

        //多个数组的交集，相同的部分
        _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
        => [1, 2]

        //数组去重
        _.uniq([1, 2, 1, 4, 1, 3]);
        => [1, 2, 4, 3]

        //将数组合并成一个对象
        _.object(['moe', 'larry', 'curly'], [30, 40, 50]);
        => {moe: 30, larry: 40, curly: 50}

        _.object([['moe', 30], ['larry', 40], ['curly', 50]]);
        => {moe: 30, larry: 40, curly: 50}


3. 对象

        //获取对象中的所有属性，返回一个数组
        _.keys({one: 1, two: 2, three: 3});
        => ["one", "two", "three"]

        //获取对象中所有的属性值，返回一个数组
        _.values({one: 1, two: 2, three: 3});
        => [1, 2, 3]

        //类似于map，但是是针对对象的
        _.mapObject({start: 5, end: 12}, function(val, key) {
            return val + 5;
        });
        => {start: 10, end: 17}





## 12. handlebars的使用规则

1. 首先需要在页面中写入一个模板的基本的html页面

        script(type="text/x-handlebars-template",id="edit_question")
            div#option_div(style='margin-top:10px;margin-bottom:10px;')
                div#option_edit_list.flex(style="flex-direction:column;margin-top:10px;")
                    {{#each question_options}}
                    div.flex.set_center(style="margin-top:10px;")
                        {{#eq ../question_type "单选"}}
                        {{#if is_answer}}
                        input(type="radio",style="margin-right:10px",name="choice_check",checked,data-index="{{@index}}")
                        {{else}}
                        input(type="radio",style="margin-right:10px",name="choice_check",data-index="{{@index}}")
                        {{/if}}
                        {{else}}
                        {{#if is_answer}}
                        input(type="checkbox",style="margin-right:10px",name="choice_check",checked,data-index="{{@index}}")
                        {{else}}
                        input(type="checkbox",style="margin-right:10px",name="choice_check",data-index="{{@index}}")
                        {{/if}}
                        {{/eq}}
                        input(type="text",style="width:170px;margin-right:10px",name="edit_option_name",data-index="{{@index}}",value="{{option_name}}")
                        .add_option.floating-button(style="width: 20px;height: 20px;background: #fff;border: #999 solid 1px;margin-right:10px")
                            i.icon-plus(style="font-size:14px;color:#999")
                        .delete_option.floating-button(style="width: 20px;height: 20px;background: #fff;border: #999 solid 1px;margin-right:10px")
                            i.icon-minus(style="font-size:14px;color:#999")
                    {{/each}}
                {{#if reference_answer}}
                div.flex(style="flex-direction:column;margin-top:10px;")
                    div.flex.set_center
                        textarea#edit_question_desc(style="width:300px;resize:none;",rows="3") {{reference_answer}}
                {{/if}}
            div(style='margin-top:10px;margin-bottom:10px')
                span 分值&nbsp;
                input#edit_question_score(type="number",style="width:280px",value="{{question_score}}")
            div(style='margin-top:10px;margin-bottom:10px')
                span 标签&nbsp;
                span#editTags
                    {{#each question_tags}}
                    span(style="padding:5px 10px;margin:0px 10px 10px 0px;",class="badge badge-info") {{this}}
                    {{/each}}
                div#edit_tags(style="display:inline;margin:0px 10px 10px 0px;left:10px;cursor:pointer")
                    i.icon.iconfont.icon-icon_xinjian(style="position:relative;top:5px;font-size:20px;color:#54c7fc;margin-top:20px;")

> 里面基本的语法包括{{变量}} {{#if}}{{else}}{{/if}} {{#each}} 简单的循环和判断

2. 然后获取模板里面的内容

        var template = Handlebars.compile($("#edit_question").html());

3. 获取到内容之后，我们要将动态的数据渲染到模板中，这时候如果需要模板内容变化的话，我们只需要重复调用这个就可以了

        $('#edit_quetion_template').html(template({
            question_type:question_type,
            question_tags:tempData.question_tags,
            reference_answer:tempData.reference_answer,
            question_options:tempData.question_options,
            question_score:tempData.question_score
            }));

什么时候用取决于你自己，但是记住，在用的时候一般用于需要动态切换、动态变化的场景，你可以理解为需要大面积更新dom的时候,或者是根据事件动态发生dom变化的时候





## 13. 数据库表的分析

1. client.js

- clientcontracts表

用户付费了以后应该会得到一个clientcontracts表的数据，里面记录了该企业签订合同的内容，合同签约人数、用户数量的控制、合同签署并开通的模块、使用次数的控制、等等合同的信息和使用次数的限制

- clientContact表

这里记录的应该是企业方面的联系人相关信息

- client表（这个是企业的主表）

这个表是付费用户的企业信息表，也是一张主表，几乎所有的页面都会拿到client的信息，里面有个字段是contract_modules是我们开通的各种模块，menus里面是我们授权的菜单，关联Menu表

- IMMessageQueue 待发送的消息队列

- IMMessageHistory 已经发送的消息的历史记录

- SMSQueue 短信发送的消息队列

- SMSHistory 短信发送的历史记录

- EmailQueue 发送短息的消息队列

- WXMessageQueue 微信企业号的队列

- HomeMessage 我们首页的消息队列，推送给自己人

- AccessLog 用户的操作日志

- UserLoginLog 用户登录的日志

- UserOpLog 

- QueueTask 应该派发任务的

2.  structure.js 公司表 

公司表其实就是购买用户旗下的公司,公司可以有上下级之间的关系，在创建公司的可以可以选择上级的公司，但是这个还是不多见的，但是提供了这个功能


- client 关联client
- company_code 公司的代码
- company_name 公司名称

3. organizationUnit 部门表 组织单元

创建部门的时候也可以选择上级部门，同样拥有上级部门的选项,需要选一家公司

- client 关联client
- ou_code 组织单元代码
- ou_name 组织单元名称
- parent_ou 直接上级部门
- positions 该部门挂靠的职位多个
- company 所属的公司
- sub_ou 直属下级部门
- sub_pos 直属下级职位一个


4. Position.js 职位相关

每一个people用户都会有一个职位Position,该职位会对应职位等级Jobrank(p678)、职务career(职位类型,更大的范围),一个职务可以有多个职位,例如经理是一个职务，人事部经理是一个职位

集团 ----> 公司 -----> 部门 -----> 职位 -----> 人

- client 关联client
- belongto_ou 所属的组织,或者叫做部门
- position_code 职位代码
- position_name 职位名称
- company 所属的公司
- position_direct_superior 直接上级
- sub_positions 当前职位下的所有下级职位


```无论是公司、部门、职位都可以直接获取到它的上级,但如果要生成树结构却远远不够的```







5. User.js（对应的应该是我们的登录用户，有权限登录进入系统的用户）

这个表对应的应该是所有登录这个系统的用户，里面包括了各种不同的权限的角色，roles数组里面放着这个用户的所有的角色，关联着RoleClient表，menu是这个用户能看到的菜单选项,也就是页面权限表

User.js中的menu表示根据client中授权的menu ----> 用户的角色对应的menu 层层过滤得来的,首先它必须存在于client的menu中，并且也要存在于用户角色对应的menu中,取个交集就是最终的用户的页面权限

RoleClient是角色表，而角色其实就是某个模块的管理员，负责管理某个模块下的所有页面

一个用户可以拥有多个角色,每个角色拥有若干的权限，用户-角色-权限

角色是什么？可以理解为一定数量的权限的集合，权限的载体。例如，一个论坛系统，超级管理员，版主都是角色。版主可以管理版内的帖子、可管理版内的用户等，这些是权限。

要给某个用户授予这些权限，只需要将版主这个角色给用户即可

当用户量非常大的时候，要给系统每个用户逐一的授权(授角色),比较繁琐。。。可考虑给用户分组,每个用户组内有多个用户。除了可给用户授权外，还可以给用户组授权，这样一来，用户拥有的所有权限 = 用户个人的权限 + 用户组的权限


具体的实践: Menu表中保存了所有页面访问的路径,如果要新增菜单的话(指的是一级菜单和展开后的二级菜单),需要添加到Menu表中,但感觉具体有用的信息都是在tcode中,{"title":"职务序列-新增","url":"/admin/masterdata/jobsequence/add","enabled":true},

用户购买了平台后，我们用000账号赋予用户所购买的模块,client中保存的就是用户购买的菜单了,这个是整个client拥有的权限集合,因为每个购买用户的模块不同，所以无法统一为相同的权限列表

但是分到具体的人又有不同的角色,角色表Role是平台提供的权限表，每个role下都有具体的menu，用户自己创建的role在roleClient表中








6. People.js

这是员工跟业务相关的表,与User不同的是,User中的字段基本都是跟登录和权限有关的,而People可以看做是跟所有的业务逻辑相关的一个人的主表

总结比较重要的字段(关联其他表的字段):

- position 当前员工所处的职位,关联position表
- position(数组) 当前员工担任过的职位,关联position表
- history_position 历史职位
- superiors 直接上级,关联people表,自动计算
- my_team 全部下级,关联people表，自动计算
- payroll_start 薪酬开始的字段
- payroll_end 薪酬结束的字段
- payrolls 薪酬段,数组
- company 员工的公司,根据主职位确定,关联company表
- company_name 员工公司名称
- ou 员工所属的部门,关联OrganizationUnit表(组织单元)
- psr 该员工的人事子范围,关联PersonnelSubRange表
- eg 该员工所属的员工组
- esg 该员工所属的员工子组
- bank_account 员工的银行账户信息,关联BankAccount表
- social_insurance_account 员工的社保账户信息,关联SocialInsuranceAccount表
- sc_people 该员工的人员信息,关联SupplyChainPeople表
- people_role 该员工的人员角色,关联SupplyChainPeopleRole表
- sc_ou  该员工的人员组织,关联SupplyChainOU表
- jobgrade 员工的等级,关联JobGrade表
- jobrank 员工的职位等级，关联JobRank表 
- career 员工的职务,关联Career表
- joblevel 员工的职位层级，关联JobLevel表
- jobsequence 员工的职务序列，关联JobSequence表









7. 薪酬表

熟悉薪酬表意义重大，我们下面来依次分析薪酬表的配置

薪酬的任何字段都是跟人绑定的，每个人都有自己的薪酬配置

- people表
    - bank_account 员工的银行卡号信息
        - 每个员工都可以有多张员工卡好信息，所以这里是一个数组的信息，保存着所有员工的银行卡信息，关联bankAccount表
    - custom_fields 员工的自定义字段
        - 员工的自定义字段都是存在PeopleFieldConfigV2表里面进行关联

- 薪酬配置表(员工薪酬信息的数据)
    - CompensationPeriodSchema薪酬发放期间 这里面记录是每个公司的发薪日相关信息
    - CompensationPeriodItemSchema这个是薪酬方案的开始时间和结束时间
    - CompensationPlanSchema每个公司的薪资方案,下面有个ci_items是该薪资方案包含的薪资项目(ci字段)，另外还有每个公司的工资单字段(payroll),个税计算配置(tax_caculate_config)
    - CompensationItemSchema每个公司下的薪酬项目

- 薪酬核算表(薪酬核算的步骤和公式)

    - CompensationCalculateSchema薪酬试算
    - PeopleCompensationSchema员工的薪酬记录表(可以理解为一个员工的薪酬模板，对应的薪酬方案、薪酬项目是什么)
    - PeopleCompensationInstanceSchema 员工薪酬实例(可以理解为一个员工真实的薪酬数据)
    - CompensationAdjustSchema 薪酬调整表(薪酬有变化的数据)
    - CompensationAdjustInstanceSchema薪酬调整实例表
    



- 定薪调薪管理(感觉更像是对一个人进行薪资的审核)

                        


8. 流程表

任务

- taskInstance表 这是一个任务表,简单的说就是我们平时创建的新的任务
- taskDefine表 任何一个任务都有实例和定义,transitions是我们当前任务的整个传送的任务流程,往前走可以驳回，往后走可以继续审批....关联的是同一个表下面的某一个任务，其中process_define关联流程定义表
- absences表 这是一个集团公司下的请假类型表
- absencetimes表 这是一个集团公司下的请假的时长表,对应的12个月

流程

- ProcessDefinePlatform 流程的平台级别表,意思就是这些是我们系统内置的一些流程,我们可以将这些系统内置的流程加到我们的流程定义表中去，用户也可以自己创建自己的流程。


- ProcessDefine表 流程的定义表，每一个客户都有自己的多个流程定义,可以从系统的默认流程中创建。process_start_url是我们流程开始的url,task_process_url是我们任务的url,每个流程都会有自己可发起的范围:角色、公司、部门、职位



- ProcessInstance表 任务对应的流程实例的表 ，current_task对应着该流程目前所处的任务,collection_id应该对应着流程中的业务

业务

- TMLeaveOfAbsence 请假业务
- 请假调整流程（TMBackAfterLeaveOfAbsence)
- 市区公干，出差，加班流程（TmAbsenceOfThree）
- 加班调整流程（TmCancelAbsenceOfThree）
- 




